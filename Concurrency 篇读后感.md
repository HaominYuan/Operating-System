- 进程和线程的区别？
  - 线程共享同一个地址空间（address space)。因此可以访问相同的数据。
  - 在线程进行上下文切换的时候并不需要进行页表的切换。
- 为什么要使用多线程？
  - 加快计算的效率。例如两个超大的数组进行相加。
  - 避免 IO 的阻塞。
- 多线程和多进程使用场景的区别
  - 多线程是在同一个地址空间，因此比较适合进行数据的共享。
  - 多进程比较适合业务逻辑的分离。适合那些数据共享比较少的场景。
- 评价锁的三个标准
  - 正确性
  - 公平性
  - 效率。考虑两种情况：第一种：只有一个线程；第二种：有多个线程
- 实现锁几种方式
  - 关闭中断。一个线程可以无休止的运行。应用场景：操作系统访问自己的数据。
  - test-and-set（指令级别）。
  - compare-and-swap （指令级别）。
  - load-linked and store-conditional （指令级别）。
  - fetch-and-add（指令级别）。
- 如何避免自旋锁？
  - yield，主动放弃 CPU，让给其他已经准备好的线程。
  - 通过队列，让那些进行等待的线程直接睡眠而不是自旋。
- Linux 的锁是如何实现的？（下面的写操作皆为原子操作）
  - 使用原子操作将 mutex 的最高位置为 1，如果返回的值是 0，因为着没有线程拥有锁，因此立刻返回回。否则 mutex 加 1。
  - 不断的尝试将最高位置为 1，如果返回的值是 0，则 mutex 减 1，返回。如果 mutex 大于零，那么继续不断尝试。否则休眠。
  - 当一个线程退出时，让 mutex 最高位等于0，判断 mutex 是否为零，如果为零直接返回（没有线程正在等待），否则唤醒队列中的线程。
- 如何实现并行计数器？
  - 一个简单的想法是直接在加 1 的函数加上锁。这种方法效率太低，但准确性高。
  - 每个线程自己有一个计数器，当这个计数器超过一定的阈值以后，将线程计数器上的值加到总的计数器上，并将线程技术器上的值清零。这种方法效率高，但准确性低。
- 如何实现并行链表？
  - 仅当真正插入时，才需要获取锁。
- 如何实现并行队列？
  - 队列中有两个指针，两把锁。
  - 初始化操作：初始化一个 dummy 节点，头指针和尾指针都指向这个 dummy 节点。
  - 出队操作：锁住头指针，然后将头判断头节点的下一个节点是否为空，如果为 NULL，意味着头指针指向的是 dummy 节点，意味队列为空。
  - 入队操作：锁住尾指针，然后将节点插入。
- 如何实现哈希表？
  - 每个桶都是一个链表，锁链表即可。
- 如何不用信号量实现一个有限空间的缓存队列（生产者/消费者问题）？
  - 实现仅有一个生产者和一个消费者的队列。此时需要用 conditon variable 来实现线程之间的通信，仅需要一个条件变量即可。
  - 实现多个生产者或者多个消费者时。为了防止生产者之间互相唤醒，以及消费者之间互相唤醒，此时需要两把锁。
  - 最后注意一个小问题，需要用 while 而不是 if 来包住 vondition variable。
- 如何用信号量实现一个有限空间的缓存队列（生产者/消费者问题）？
  - 需要注意的问题是信号量保证的是控制进入临界区的线程数量，因此需要在内存加锁。
- 如何用信号量实现读写锁？
  - 用一个变量来统计目前正在读的个数，当有线程在读时，读线程将获取写锁。
- 如何用锁和条件变量实现信号量？
  - 用一个变量来统计目前临界区中线程的个数。
  - wait 函数实现：互斥锁锁住变量。判断变量是否小于等于零，如果小于等于零直接睡眠，等待唤醒。唤醒后，变量减去一。
  - post 函数实现：互斥锁锁住变量。变量加1，唤醒睡眠的线程。
- 多线程问题集合
  - Atomicity-Violation Bugs：多线程未加锁。
  - Order-Violation Bugs：线程之间存在先后顺序，但是未加条件变量。
  - Deadlock Bugs：死锁
- 为什么会出现死锁？
  - 负责的依赖关系。
  - 封装性错误。
- 死锁出现的条件：
  - 互斥条件：线程需要独占某个资源。
  - 获得并等待：资源被某个线程获取以后，该线程继续获取其他资源。
  - 没有抢占：没有办法夺取那些已经被线程占据的资源。
  - 循环等待：存在一个线程的循环等待。每一个线程所获得的资源同时是另一个线程所需要的资源。
- 如何预防死锁的出现？
  - 循环等待：比如有两把锁 L1 和 L2。规定必须先获取锁 L1 才能获取锁 L2。顺序的设定可以通过内存地址的大小来设定。
  - 获得并等待：假如有两把锁 L1 和 L2。重新声明一把锁 L3，仅当持有 L3 时，才能够同时持有锁 L1 和 锁L2。
  - 没有抢占：假如有两把锁 L1 和 L2。当获取了其中一把锁时但未获取另一把锁时，可以放弃所有的锁，重新获取。缺点是容易造成活锁，可以通过设置随机数解决。
  - 互斥条件：通过原子指令不断的尝试修改某一个数值。
  - 线程调度。
  - 检测。